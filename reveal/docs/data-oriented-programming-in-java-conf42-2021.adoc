= Data-Oriented programming in Java
include::slide.attrs[]

[state=title]
[%notitle]
== Data-Oriented programming in Java


[.centered]
--
{bl}
{bl}
{bl}
[..big-text]
*Data-Oriented programming in Java*


{bl}

_Liberate yourself from the complexity of objects_


{bl}
[.marginleft40]
image::http://www.conf42.com/assets/conf42/conf42_logo_black_small.png[width=40%]


March 2021

Yehonathan Sharvit icon:twitter[]  viebel
--

== ğŸ‘‹Who am I?

[.left.w40]
--
* ğŸ’» Developer since 2001 (C++, Java, JavaScript, Ruby, Clojure)
* ğŸ“– Author of Data-Oriented programming
* ğŸ“ Blogger at https://blog.klipse.tech/[blog.klipse.tech]
--

[.left.w50]
--
image::dop-book.png[width=65%]
--


== ğŸ¤” What is Data-Oriented Programming?
== ğŸ““ What is complexity?


[.fragment]
[quote]
--
*âš™ï¸Computational complexity*

The amount of *machine resources* (e.g. CPU, memory) required to *run* a program.
--

[.fragment]
[quote]
--
*ğŸ˜° System Complexity*

The amount of *brain resources* required to *understand* a system.

--



== ğŸ¤” What makes a system complex?

[.fragment]
[.left.w30]
image::watchmen-library.png[]

[.left.w10]
{bl}

[.fragment]
[.left.w30]
image::complex-class-relation.svg[width=100%]


[.fragment]
--
ğŸ•¸ï¸Sources of complexity
--

[.fragment]
* Nodes with many edges
* Many kind of arrows
** Association
** Composition
** Inheritance
** Usage


== {principle} Separate Code from Data
[.fragment]
--
[.bordered.w65.left]
image::from-oop-to-dop.png[width=100%]
--

[.left.w30.margin-left]
--
[.fragment]
{meditation}What makes this system _less complex_?

[.fragment]
* *Separation* of concerns
* Code diagram *constraints*
** Stateless (static)
** Only usage relation
* Data diagram *constraints*
** Only association and composition
--

== {application} Separate Code from Data in Java


[.left.w50]
[source,java]
class AuthorData {
    private String firstName;
    private String lastName;
    // setters
    // getters
}


[.left.w50]
[source,java]
class AuthorCode {
    static String fullName(AuthorData author) {
        return author.firstName() +
            " " + author.lastName();
    }
}

[.left.w50]
[source,java]
----
var asimov = new AuthorData("Isaac", "Asimov");
AuthorCode.fullName(asimov); // "Isaac Asimov"
----

== ğŸ¤” What makes code hard to understand?

Thread safety

[fragment]
[.left.w60]
--
[source,java]
----

class MemberData {
    private boolean blocked;
    private String firstName;
    private String lastName;
   // getters and setters
}
----
[source,java]
----
class MemberCode {
    static borrow(MemberData member, String bookId) {
        if(!member.isBlocked()) {
            System.out.println("The book is yours!");
        }
    }
}
----
--

[fragment]
[.left.w40]
[%step]
. âš ï¸This code is not thread safe!
. ğŸ”’ We add lock mechanisms.
. ğŸ˜± It makes the code hard to understand.

== ğŸ¤” What makes code hard to understand?


By reference or by value?

[fragment]
--
[quote]
In Java, object references are passed by value
--



[fragment]
--
[.left.w50]
[source,java]
----
var asimov = new AuthorData("Isaac", "Asimov");
var asimov2 = AuthorCode.toUpperLastName(asimov);
asimov2.lastName() // "ASIMOV"
asimov.lastName() // ??
----
--

[fragment]
[.left.w50]
--
. âš  We could trust the implementation
. ğŸ”’ We protect ourselves by copying the object
. ğŸ˜± It makes the code hard to understand

--


== {principle} Do not mutate data


[quote]
Treat data as a value. Values never change. 

Main benefits of immutable data

[%step]
. Inherently Thread-safe
. No side-effects

== {application} Immutable data in Java


[fragment]
--
[quote]
We can solve any problem in Java with Java annotations (anonymous)
--

[fragment]
--
`@value` annotation by Project Lombok
--

[.left.w50]
[fragment]
--
[source,java]
@value class AuthorData {
    String firstName;
    String lastName;
}
--

[.left.w50]
[fragment]
--
Auto generation of:

* constructor, immutable private fields
* getters,  setters
* `toString()`, `hashCode()`, `equals()`
--

== {application} Immutable data in Java

Java 14 records

[.left.w50]
[fragment]
--

[source,java]
public record AuthorData (String firstName,
                          String lastName) {}
--

[.left.w50]
[fragment]
--
Native implementation of:

* constructor, immutable private fields
* getters,  setters
* `toString()`, `hashCode()`, `equals()`
--


== {benefit} Benefits of Immutable data in Java


[.left.w60]
[fragment]
--
[source,java]
----
var asimov = new AuthorData("Isaac", "Asimov");
var asimov2 = AuthorCode.toUpperLastName(asimov);
asimov.lastName() // "asimov"
----
--

[.left.w40]
[fragment]
--
. No mutations!
. No unpleasant surprises
. No need to protect!
--

[.left.w60]
[fragment]
--
[source,java]
----
class MemberCode {
    static borrow(MemberData member, String bookId) {
        if(!member.isBlocked()) {
            System.out.println("The book is yours!");
        }
    }
}
----
--

[.left.w40]
[fragment]
--

. Thread-safe!
. No race conditions!
. No need to protect!
--



=== {benefit}Reduction of System Complexity even more

[.fragment]
[.left.w40]
--
[.bordered]
image::data-code-relation.svg[width=100%]
[.huge-text]
{dislike} {dislike} {dislike}
--

[.fragment]
[.left.w20]
--
[.bordered]
image::code-only.svg[width=100%, height=415px]
[.huge-text]
{like} {like} {like}
--


[.left.w40]
--
[.fragment]
{meditation}What makes this system _less complex_?

[.fragment]
* *Weak dependency* between code and data
* *Flexible* data model
* *Generic* data manipulation functions
--


=== {benefit} Visualize the system data

[.fragment]
[.left.w50]
image::library-data.svg[width=100%]


[.fragment]
[.left.w50]
* Information *path* (e.g. `["catalog", "authorsById", "alan-moore", "name"]`)
* *Display* data on console
* *Serialization* for free
* *Reflection* for free


== ğŸ¤” What about immutable collections?

== â³Summary

{bl}
{bl}
{bl}
{bl}
[.centered90]
image::java-do.png[]


